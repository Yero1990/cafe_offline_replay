/* 
   ------------------
   Author: C. Yero
   
   Brief: A compilation of CaFe utility functions
   for plotting histograms / reading summary files 
   and performing numerical operations on them
   
   ------------------
*/ 

// define global directories for post-analysis
#define SUMMARY_FILES_DIR "summary_files/"                  // output summary (.csv) files generated by cafe analysis
#define ANALYZED_COMBINED "/Users/deuteron/ROOTfiles/pass3_files/data/combined/"
// "analyzed_files/combined/"       // output analyzed combined (.root) files generated by cafe analysis 
#define ANALYZED_INDIVIDUAL "analyzed_files/individual/"   // output analyzed individual (.root, .report) files generated by cafe analysis 


#include "../../UTILS_CAFE/UTILS/parse_utils.h"
#include "../../UTILS_CAFE/UTILS/read_csv.h"
#include "../../UTILS_CAFE/UTILS/vector_operations.h"
#include "../../UTILS_CAFE/UTILS/hist_utils.h"

struct compare
{
  int key;
compare(int const &i): key(i) {}
  
  bool operator()(int const &i) {
    return (i == key);
  }
};

//___________________________________________________________________________
double get_header(string header="", string target="", string kin="", int run=-1){
  
  /* brief: returns either total or average value (depends on column) for selected data column header from the
     cafe summary files.  The summary files are assumed to be in a fixed location and have 
     the generic format: cafe_prod_<target>_<kin>_report_summary.csv 

     if run!=0, then will try to find vector array index of user-defined run
     and output the corresponding header value for the given run instead


     ----------
     arguments:
     ----------
     header: "total_charge", "real_yield", "real_yield_err", "hms_trk_eff", "hms_trk_eff_err", "shms_trk_eff", "shms_trk_eff_err"
     target: "LD2", "Be9",  "B10",  "B11",  "C12",  "Ca40",  "Ca48",  "Fe54"
     kin:    "MF", "SRC"
     
   */
  
  
  //SUMMARY_FILES_DIR
  // set generic .csv file name
  string file_csv = Form(SUMMARY_FILES_DIR"pass3/cafe_prod_%s_%s_report_summary.csv", target.c_str(), kin.c_str());

  //cout << Form("FILE TO OPEN: %s", file_csv.c_str()) << endl;
  
  // set run index to -1, and define the run vector
  int run_idx = -1;
  vector<double> v_run         = read_csv(file_csv.c_str(), "run");
  
  //---------------- check if user input a run ---------------
  if(run!=-1){
    
    // search for run number
    auto itr = std::find_if(v_run.cbegin(), v_run.cend(), compare(run));
    
    // if run is found, get the index
    if (itr != v_run.cend()) {
      run_idx = std::distance(v_run.cbegin(), itr);
      cout << "run index:" << run_idx << endl;
      
    }
    else {
      std::cout << "run number not found" << endl;
      cout << "run index:" << run_idx << endl;
    }
  }
  //---------------------------------------------------------
    
    
    // return total charge (sums over charge for each run)
  if( header.compare("total_charge")==0 ){

    
    vector<double> v_charge         = read_csv(file_csv.c_str(), "charge"); // mC
    double charge = vsum(v_charge);

    // check if run number is detected, and get the value using the index
    if(run_idx!=-1){
      charge =  v_charge.at(run_idx);
    }
    
    return charge;
  }

  // return total yield (sums over real yield for each run)
  if( header.compare("real_yield")==0 ){
    
    vector<double> v_real_Yield     = read_csv(file_csv, "real_Yield");
    double real_Yield = vsum(v_real_Yield);

    // check if run number is detected, and get the value using the index
    if(run_idx!=-1){
      real_Yield  =  v_real_Yield.at(run_idx);
    }
    
    return real_Yield;
  }

  // return total yield err ( root of the sum of errors ^{2} ) - basic error propagation for sum of variables  
  if( header.compare("real_yield_err")==0 ){
    
    vector<double> v_real_Yield_err = read_csv(file_csv, "real_Yield_err");
    double real_Yield_err = sqrt( vsum ( vpow(v_real_Yield_err, 2) ) ); // sqrt [  err_1^{2} + err_2^{2} + . .  . err_n^{2} ]

    // check if run number is detected, and get the value using the index
    if(run_idx!=-1){
      real_Yield_err  =  v_real_Yield_err.at(run_idx);
    }
    
    return real_Yield_err;
    
  }

  // return weighted avg HMS tracking (and error) efficiency (presumably tracking efficiency is ~ same for every run of the same kinematic)
  if( header.compare("hms_trk_eff")==0 || header.compare("hms_trk_eff_err")==0 ){

    vector<double> v_hTrkEff        = read_csv(file_csv, "hTrkEff");
    vector<double> v_hTrkEff_err    = read_csv(file_csv, "hTrkEff_err");

    //error in weighted average is passed by reference
    double hms_trk_eff_err = 0;          

    // calculated weighted average of a vector of elements
    double hms_trk_eff              = vavgw(v_hTrkEff, v_hTrkEff_err, hms_trk_eff_err);  

    
    if( header.compare("hms_trk_eff")==0 ){

      // check if run number is detected, and get the value using the index
      if(run_idx!=-1){
	hms_trk_eff  =  v_hTrkEff.at(run_idx);
      }
    
      return hms_trk_eff;
    }

    if( header.compare("hms_trk_eff_err")==0 ){

      if(run_idx!=-1){
	hms_trk_eff_err  =  v_hTrkEff_err.at(run_idx);
      }
	 
      return hms_trk_eff_err;
    }    

  }

  // return weighted avg SHMS tracking (and error) efficiency (presumably tracking efficiency is ~ same for every run of the same kinematic)
  if( header.compare("shms_trk_eff")==0 || header.compare("shms_trk_eff_err")==0 || header.compare("shms_mult_trk_eff")==0 ){

    vector<double> v_pTrkEff        = read_csv(file_csv, "pTrkEff");
    vector<double> v_pTrkEff_err    = read_csv(file_csv, "pTrkEff_err");

    vector<double> v_pMultiTrkEff        = read_csv(file_csv, "multi_track_eff");
    vector<double> v_pMultiTrkEff_err( v_pMultiTrkEff.size(),0.001); // no errors until figure out proper way to calculate them

    //cout << "v_pMultiTrkEff : " << v_pMultiTrkEff.at(0)  << endl;
    //cout << "v_pMultiTrkEff_err : " << v_pMultiTrkEff_err.at(0)  << endl;

    //error in weighted average is passed by reference
    double shms_trk_eff_err = 0;          
    double shms_mult_trk_eff_err = 0;          

    // calculated weighted average of a vector of elements
    double shms_trk_eff              = vavgw(v_pTrkEff, v_pTrkEff_err, shms_trk_eff_err);  

    double shms_mult_trk_eff         = vavgw(v_pMultiTrkEff, v_pMultiTrkEff_err, shms_mult_trk_eff_err);
    //cout << "shms_mult_trk_eff :" << shms_mult_trk_eff  << endl;
    
    if( header.compare("shms_trk_eff")==0 ){

      if(run_idx!=-1){
	shms_trk_eff  =  v_pTrkEff.at(run_idx);
      }
      return shms_trk_eff;
    }

    if( header.compare("shms_trk_eff_err")==0 ){

      if(run_idx!=-1){
	shms_trk_eff_err  =  v_pTrkEff_err.at(run_idx);
      }
	
      return shms_trk_eff_err;
    }

    if( header.compare("shms_mult_trk_eff")==0 ){
      
      if(run_idx!=-1){
	shms_mult_trk_eff  =  v_pMultiTrkEff.at(run_idx);
      }
      
      return shms_mult_trk_eff;
    }   

  }


  // return weighted avg total live time (presumably live time is ~ same for every run of the same kinematic)
  if( header.compare("total_live_time")==0 || header.compare("total_live_time_err")==0 ){

   
    vector<double> v_tLT            = read_csv(file_csv, "tLT");
    vector<double> v_tLT_err        = read_csv(file_csv, "tLT_err_Bi");

    //error in weighted average is passed by reference
    double total_live_time_err = 0;          

    // calculated weighted average of a vector of elements
    double total_live_time              = vavgw(v_tLT, v_tLT_err, total_live_time_err);  

    
    if( header.compare("total_live_time")==0 ){

      if(run_idx!=-1){
	total_live_time  =  v_tLT.at(run_idx);
      }
	
      return total_live_time;
    }

    if( header.compare("total_live_time_err")==0 ){

      if(run_idx!=-1){
	total_live_time_err  =  v_tLT_err.at(run_idx);
      }
	  
      return total_live_time_err;
    }    

  }

  
  return 0;
  
  }
  
  //__________________________________________________________________
  double get_param( string var="", string target="", string kin="" ){
  
  // brief: function to read parameters from the .csv files


  // set generic .csv file name
  string file_csv = Form(SUMMARY_FILES_DIR"pass3/cafe_prod_%s_%s_report_summary.csv", target.c_str(), kin.c_str());

  // find parameters in .csv. files (usually commented lines above header in .csv file)

  //cout << Form("FILE TO OPEN: %s", file_csv.c_str() ) << endl;

  double tgt_area_density = stod(split(FindString("target_areal_density", file_csv.c_str(), false, -1, true)[0], ':')[1]);
  double transparency     = stod(split(FindString("transparency:", file_csv.c_str(),        false, -1, true)[0], ':')[1]);

  double N     = stod(split(FindString("N:", file_csv.c_str(),        false, -1, true)[0], ':')[1]);
  double Z     = stod(split(FindString("Z:", file_csv.c_str(),        false, -1, true)[0], ':')[1]);
  double A     = stod(split(FindString("A:", file_csv.c_str(),        false, -1, true)[0], ':')[1]);


  if( var.compare("tgt_area_density")==0 ){
    return tgt_area_density;
  }

  if( var.compare("transparency")==0 ){
    return transparency;
  }

  if( var.compare("N")==0 ){
    return N;
  }

  if( var.compare("Z")==0 ){
    return Z;
  }
  
  if( var.compare("A")==0 ){
    return A;
  }


  return 0.;
  
}

//____________________________________________________________________________________________________
void compare_histos( TString file_path="path/to/file1.root",
		     vector<TString> hist_name={}, vector<int> clr={}, vector<TString> hist_leg={},
		     TString xlabel="X-label [units]", TString ylabel="Y-label [units]", TString title="title",
		     bool norm=false)
{

  /* brief: generic function to compare (overlay) N-number of a histograms with different cuts from the same file 
     (e.g. study cut variation of a histogram)
     
     The arguments are as follows:

     file_path             : ROOTfile paths ( /path/to/file.root )
     hist1, hist2          : complete path to histogram objects in file (for example if they are in a sub-direcotry, then it must be specified ("path/to/hist_object")
     xlabel, ylabel, title : self-explanatory (axis labels and plot title)
     hist1_leg, hist2_leg  : histograms legend names that can help identify what the histogram being plotted is
     norm                  : boolean flag that if set to true, draws the histograms normalized to an area of 1

   */


  int font_type = 132;

  gStyle->SetOptStat(0);
  gStyle->SetTitleFontSize(0.07);
  gStyle->SetTitleFont(font_type, "");
  gStyle->SetLegendBorderSize(0);
  gStyle->SetLegendFont(font_type);
  gStyle->SetLegendTextSize(0.03);
  

  //Open  ROOT files;
  TFile *file = NULL;

  file = new TFile(file_path.Data());




  // loop over all histogram names to be overlayed
  for(int i=0; i<hist_name.size(); i++) {

    
    // declare canvas to draw overlay histos
    TCanvas *c = new TCanvas(Form("c_%s",hist_name[i].Data()), Form("%s", hist_name[i].Data()), 900, 700);

 
    TLegend *leg = new TLegend(0.14,0.89,0.25,0.78);

  
    // declare 1D histos
    TH1F *H_hist = 0;  

    // get histogram objects
    file->cd();
    file->GetObject(hist_name[i].Data(), H_hist);
    // set histos aethetics
    H_hist->SetLineColor(clr[i]);

    //H_hist->SetFillColorAlpha(clr[i], 0.40);
    H_hist->SetFillColor(clr[i]);
    //H_hist->SetFillStyle(3004+i);
    

    // set y-range
    // H_hist->GetYaxis()->SetRangeUser(0.001, H_hist->GetMaximum()+0.6*H_hist->GetMaximum());
    
    // set histogram titles/labels/font
    H_hist->SetTitle(title.Data());

    H_hist->GetXaxis()->SetLabelSize(0.04);
    H_hist->GetYaxis()->SetLabelSize(0.04);
    
    H_hist->GetYaxis()->SetTitle(ylabel.Data());
    H_hist->GetXaxis()->SetTitle(xlabel.Data());

    H_hist->GetYaxis()->CenterTitle();
    H_hist->GetXaxis()->CenterTitle();
    
    H_hist->SetLabelFont(font_type, "XY");
    H_hist->SetTitleFont(font_type, "XY");
    H_hist->SetTitleSize(0.04, "XY");
    H_hist->SetTitleOffset(1.1, "X");
    H_hist->SetTitleOffset(1.4, "Y");
  
    
    if(norm) {

      if(i==0){
	H_hist->DrawNormalized("histE0");
      }
      else{
	H_hist->DrawNormalized("sameshistE0");
      }
    }

    else{ 
      if(i==0){
	H_hist->Draw("histE0");
      }
      else{
	H_hist->Draw("sameshistE0");
      }
    }
    
   
    
    // create legend ( displays hist legend label and integral counts)
    double h_I;
    double h_Ierr;
    double nbins = H_hist->GetNbinsX();  //Get total number of bins (excluding overflow)
    h_I = H_hist->IntegralAndError(1, nbins, h_Ierr);


    leg->AddEntry(H_hist,Form("%s | Integral: %.1f \n", hist_leg[i].Data(), h_I),"f");


    // draw legend
    leg->Draw();


  } // end loop over hist names
  
 
}

//____________________________________________________________________________________________________
void compare_histos( TString file1_path="path/to/file1.root", TString hist1="kin_plots/H_Pm", Double_t scale1=1,
		     TString file2_path="path/to/file2.root", TString hist2="kin_plots/H_Pm", Double_t scale2=1,
		     TString xlabel="X-label [units]",          TString ylabel="Y-label [units]", TString title="title",
		     TString hist1_leg="hist1_legend_title", TString hist2_leg="hist2_legend_title", bool norm=false)
{

  /* brief: generic function to compare (overlay) two 1D histograms from different files (assuming they have same binning)
     
     The arguments are as follows:

     file1_path, file2_path: ROOTfile paths ( /path/to/file.root )
     hist1, hist2          : complete path to histogram objects in file (for example if they are in a sub-direcotry, then it must be specified ("path/to/hist_object")
     scale1, scale2        : user can input by how much to scale hist1,2 as follows:  hist1->Scale(scale1), hist2->Scale(scale2)
     xlabel, ylabel, title : self-explanatory (axis labels and plot title)
     hist1_leg, hist2_leg  : histograms legend names that can help identify what the histogram being plotted is
     norm                  : boolean flag that if set to true, draws the histograms normalized to an area of 1

   */


  int font_type = 132;

  gStyle->SetOptStat(0);
  gStyle->SetTitleFontSize(0.07);
  gStyle->SetTitleFont(font_type, "");
  gStyle->SetLegendBorderSize(0);
  gStyle->SetLegendFont(font_type);
  gStyle->SetLegendTextSize(0.03);
  

  //Open  ROOT files;
  TFile *file1 = NULL;
  TFile *file2 = NULL;

  file1 = new TFile(file1_path.Data());
  file2 = new TFile(file2_path.Data());

  // declare 1D histos
  TH1F *H_hist1 = 0;  
  TH1F *H_hist2 = 0;

  // get histogram objects
  file1->cd();
  file1->GetObject(hist1.Data(), H_hist1);
  file2->cd();
  file2->GetObject(hist2.Data(), H_hist2);

  // set histos aethetics
  H_hist1->SetLineColor(kBlue);
  H_hist1->SetMarkerColor(kBlue);
  H_hist1->SetMarkerStyle(8);
  
  //H_hist1->SetFillColorAlpha(kRed, 0.40);
  //H_hist1->SetFillStyle(3004);

  H_hist2->SetLineColor(kRed);
  H_hist2->SetMarkerColor(kRed);
  H_hist2->SetMarkerStyle(8);
  //H_hist2->SetFillColorAlpha(kBlue, 0.40);
  //H_hist2->SetFillStyle(3005);

  // set y-range
  H_hist1->GetYaxis()->SetRangeUser(0, H_hist1->GetMaximum()+1.6*H_hist1->GetMaximum());
  H_hist2->GetYaxis()->SetRangeUser(0, H_hist1->GetMaximum()+1.6*H_hist1->GetMaximum());

  // set histogram titles/labels/font
  H_hist1->SetTitle(title);
  
  H_hist1->GetXaxis()->SetLabelSize(0.04);
  H_hist1->GetYaxis()->SetLabelSize(0.04);
  
  H_hist1->GetYaxis()->SetTitle(ylabel);
  H_hist1->GetXaxis()->SetTitle(xlabel);

  H_hist1->GetYaxis()->CenterTitle();
  H_hist1->GetXaxis()->CenterTitle();

  H_hist1->SetLabelFont(font_type, "XY");
  H_hist1->SetTitleFont(font_type, "XY");
  H_hist1->SetTitleSize(0.05, "XY");
  H_hist1->SetTitleOffset(1., "XY");


  TCanvas *c = new TCanvas(Form("c_%s", title.Data()), Form("%s", title.Data()), 900, 700);
  c -> SetLeftMargin(0.12);
  c -> SetBottomMargin(0.12);
  // scale histograms (default is 1, but user can input different value)
  H_hist1->Scale(scale1);
  H_hist2->Scale(scale2);

  gStyle->SetErrorX(0);
  
  H_hist1->Draw("PEX0");
  H_hist2->Draw("samesPEX0");


  if(norm) {
    H_hist1->DrawNormalized("PEX0");
    H_hist2->DrawNormalized("samesPEX0");
    
  }

  
  // create legend ( displays hist legend label and integral counts)
  // TLegend *leg = new TLegend(0.14,0.89,0.25,0.78);
  TLegend *leg = new TLegend(0.6,0.89,0.7,0.78);
  double h1_I, h2_I;
  double h1_Ierr, h2_Ierr;
  double nbins = H_hist1->GetNbinsX();  //Get total number of bins (excluding overflow)
  h1_I = H_hist1->IntegralAndError(1, nbins, h1_Ierr);
  h2_I = H_hist2->IntegralAndError(1, nbins, h2_Ierr);

  double R = h1_I / h2_I;
  double R_err = abs(R) * sqrt( pow(h1_Ierr/h1_I,2) + pow(h2_Ierr/h2_I,2) );
  
  leg->AddEntry(H_hist1,Form("%s | Integral: %.3f", hist1_leg.Data(), h1_I));
  leg->AddEntry(H_hist2,Form("%s | Integral: %.3f", hist2_leg.Data(), h2_I));
  leg->AddEntry((TObject*)0, TString::Format("%s / %s = %.3f #pm %.3f", hist1_leg.Data(), hist2_leg.Data(), R, R_err), "");
  
  // draw legend
  leg->Draw();
  
  
}

//____________________________________________________________________________________________________
void compare_histos(
		    TH1F *H_hist1=0, TH1F *H_hist2 = 0, 
		    TString xlabel="X-label [units]", TString ylabel="Y-label [units]", TString title="title",
		    TString hist1_leg="hist1_legend_title", TString hist2_leg="hist2_legend_title", bool norm=true) {

  /* brief: generic function to compare (overlay) two 1D histograms (assuming they have same binning)
     (note this has the same name as function that takes file paths, this is referred to as function overloading, and allows
     the user to utilize different variations of the same function)

     The arguments are as follows:

     H_hist1, H_hist2      : pre-defined user histogram objects (must have same binning)
     xlabel, ylabel, title : self-explanatory (axis labels and plot title)
     hist1_leg, hist2_leg  : histograms legend names that can help identify what the histogram being plotted is
     norm                  : boolean flag that if set to true, draws the histograms normalized to an area of 1

   */

  gStyle->SetOptStat(0);

  int font_type = 132;

  gStyle->SetOptStat(0);
  gStyle->SetTitleFontSize(0.07);
  gStyle->SetTitleFont(font_type, "");
  gStyle->SetLegendBorderSize(0);
  gStyle->SetLegendFont(font_type);
  gStyle->SetLegendTextSize(0.03);

  // set histos aethetics
  H_hist1->SetLineColor(kRed);
  H_hist1->SetFillColorAlpha(kRed, 0.40);
  H_hist1->SetFillStyle(3004);

  H_hist2->SetLineColor(kBlue);
  H_hist2->SetFillColorAlpha(kBlue, 0.40);
  H_hist2->SetFillStyle(3005);

  // set y-range
  H_hist1->GetYaxis()->SetRangeUser(0, H_hist1->GetMaximum()+0.6*H_hist1->GetMaximum());

  // set histogram titles/labels/font
  H_hist1->SetTitle(title);
  
  H_hist1->GetXaxis()->SetLabelSize(0.04);
  H_hist1->GetYaxis()->SetLabelSize(0.04);
  
  H_hist1->GetYaxis()->SetTitle(ylabel);
  H_hist1->GetXaxis()->SetTitle(xlabel);

  H_hist1->GetYaxis()->CenterTitle();
  H_hist1->GetXaxis()->CenterTitle();

  H_hist1->SetLabelFont(font_type, "XY");
  H_hist1->SetTitleFont(font_type, "XY");
  H_hist1->SetTitleSize(0.05, "XY");
  H_hist1->SetTitleOffset(1., "XY");


  TCanvas *c = new TCanvas("c", "c", 900, 700);

  H_hist1->Draw("histE0");
  H_hist2->Draw("sameshistE0");


  if(norm) {
    H_hist1->DrawNormalized("histE0");
    H_hist2->DrawNormalized("sameshistE0");
  }
  
  // create legend ( displays hist legend label and integral counts)
  TLegend *leg = new TLegend(0.14,0.89,0.25,0.78);
  double h1_I, h2_I;
  double h1_Ierr, h2_Ierr;
  double nbins = H_hist1->GetNbinsX();  //Get total number of bins (excluding overflow)
  h1_I = H_hist1->IntegralAndError(1, nbins, h1_Ierr);
  h2_I = H_hist2->IntegralAndError(1, nbins, h2_Ierr);
  
  leg->AddEntry(H_hist1,Form("%s | Integral: %.3f", hist1_leg.Data(), h1_I),"f");
  leg->AddEntry(H_hist2,Form("%s | Integral: %.3f", hist2_leg.Data(), h2_I));
  // draw legend
  leg->Draw();

  c->Show();
  
}


//____________________________________________________________________________________________________
void overlay_nuclei(vector<string> tgt={}, vector<int> clr={}, string kin="", string hist_name="",
		    string xlabel="X-label [units]", string ylabel="Y-label [units]", string title="title"){

  /* 
     brief: cafe-specific plotting utility to overlay n nuclei histograms, assuming a generic filename that varies only with (target, kin)
     the user may change this generic file-name accordingly

     -----------
     arguments:
     -----------
     tgt {}: string vector array to hold target names (must be consistent with target as found in file name)
     clr {} : integer vector array to hold plotting colors of each target ( colors represented by integers, see https://root.cern.ch/doc/master/classTColor.html )
     kin   : single string to select kinematic setting for specified targets ("MF" or "SRC")
     hist_name : histogram object name (if histogram is in ROOT file sub-directory, then it must also be specified)
     xlabel, ylabel, title : strings to set histogram axis and title labels

     -----------------------
     example of code usage:
     -----------------------

     vector<string> tgt = {"LD2", "Be9", "B10", "B11", "C12"};
     vector<int> clr     = {2, 4, 6, 8, 9}; 
     overlay_nuclei(tgt, clr, "MF", "kin_plots/H_Pm", "Missing Momentum [GeV/c]", "Normalized Counts", "Missing Momentum (light nuclei)");
 
  */
  
  // dont show stats box
  gStyle->SetOptStat(0);

  // set global plotting style
  int font_type = 132;

  gStyle->SetOptStat(0);
  gStyle->SetTitleFontSize(0.07);
  gStyle->SetTitleFont(font_type, "");
  gStyle->SetLegendBorderSize(0);
  gStyle->SetLegendFont(font_type);
  gStyle->SetLegendTextSize(0.03);
  
  
  string fname;
  
  TCanvas *c = new TCanvas(Form("C_%s", kin.c_str()), "", 900, 700);
  TLegend *leg = new TLegend(0.14,0.89,0.25,0.70);

  // loop over each file name
  for (int i=0; i<tgt.size(); i++){

    // generic file name with specific target, kinematic
    fname = Form(ANALYZED_COMBINED"pass3/cafe_prod_%s_%s_combined.root", tgt[i].c_str(), kin.c_str());

    //cout << Form("FILE TO OPEN: %s", fname.c_str()) << endl;

    //cout << "fname = " << fname << endl;
    //cout << clr[i] << endl;
    // read TFile
    TFile *file = NULL;
    file = new TFile(fname.c_str());
  
    TH1F *H_hist =0;
    
    file->cd();
    file->GetObject(hist_name.c_str(), H_hist);

    // set histos aethetics
    H_hist->SetLineColor(clr[i]);
    H_hist->SetLineWidth(2);
    H_hist->SetMarkerStyle(8);
    H_hist->SetMarkerSize(0.8);
    H_hist->SetMarkerColor(clr[i]);
	

    //H_hist->SetFillColorAlpha(clr[i], 0.40);
    //H_hist->SetFillStyle(3002);
    
    // set y-range
    H_hist->GetYaxis()->SetRangeUser(0.1, H_hist->GetMaximum()+0.6*H_hist->GetMaximum());
    
    // set histogram titles/labels/font
    H_hist->SetTitle(title.c_str());
    
    H_hist->GetXaxis()->SetLabelSize(0.04);
    H_hist->GetYaxis()->SetLabelSize(0.04);
    
    H_hist->GetYaxis()->SetTitle(ylabel.c_str());
    H_hist->GetXaxis()->SetTitle(xlabel.c_str());
    
    H_hist->GetYaxis()->CenterTitle();
    H_hist->GetXaxis()->CenterTitle();
    
    H_hist->SetLabelFont(font_type, "XY");
    H_hist->SetTitleFont(font_type, "XY");
    H_hist->SetTitleSize(0.05, "XY");
    H_hist->SetTitleOffset(1., "XY");
    H_hist->SetStats(0);
    // changed to canvas and draw
    c->cd();
    if(tgt.size()==1) { H_hist->DrawNormalized("histE0") ;}
    else{
      H_hist->DrawNormalized("sameshistE0");
    }

    // add legend entry
    leg->AddEntry(H_hist,Form("%s %s", tgt[i].c_str(), kin.c_str()),"f");

  }

  leg->Draw();
  
}



//_______________________________________________________________________________________________
vector<TH1F*> get_single_ratios(string tgtA="",  string kinA="", string tgtB="", string kinB="",
				string hist_name="",  bool show_histos=false ){
  
  // brief: calculate single ratios of binned histograms (hist_name) for  each combination of <target, kinematics>: R = tgtA_kinA / tgtB_kinB  
  // using the analyzed CaFe *_combined.root files .  Example:  Ca48 MF / Ca40 MF,  Fe54 SRC / Ca48 SRC, etc.
  // The histograms, A and B, are scaled to total charge, transparency, target thickness, track efficiency and live time
  // The user may modify the scaling as desired


  
  // define histogram scale variables 
  double scale_factor_A,  Q_A,  hms_trk_eff_A,  shms_trk_eff_A, shms_mult_trk_eff_A,  total_LT_A, transparency_A, tgt_area_density_A, A_tgtA, Z_tgtA;
  double scale_factor_B,  Q_B,  hms_trk_eff_B,  shms_trk_eff_B, shms_mult_trk_eff_B,  total_LT_B, transparency_B, tgt_area_density_B, A_tgtB, Z_tgtB;


  //-------------------------------------------------------
  //  APPLY SCALE FACTOR TO HISTOGRAMS (VERY IMPORTANT)
  // get info from summary files (for scaling histograms)
  //-------------------------------------------------------

  // total charge
  Q_A  = get_header("total_charge", tgtA.c_str(),  kinA.c_str());    
  Q_B = get_header("total_charge", tgtB.c_str(),  kinB.c_str());

  // weighted average of HMS track efficiency
  hms_trk_eff_A   = get_header("hms_trk_eff",  tgtA.c_str(), kinA.c_str() );
  hms_trk_eff_B   = get_header("hms_trk_eff",  tgtB.c_str(), kinB.c_str() );    

  // weighted average of SHMS track efficiency
  shms_trk_eff_A  = get_header("shms_trk_eff", tgtA.c_str(), kinA.c_str() );
  shms_trk_eff_B  = get_header("shms_trk_eff", tgtB.c_str(), kinB.c_str() );

  // weighted average of SHMS MULTI-track efficiency
  shms_mult_trk_eff_A  = get_header("shms_mult_trk_eff", tgtA.c_str(), kinA.c_str() );
  shms_mult_trk_eff_B  = get_header("shms_mult_trk_eff", tgtB.c_str(), kinB.c_str() );

  
  // weighted average of total live time
  total_LT_A      = get_header("total_live_time", tgtA.c_str(),  kinA.c_str());
  total_LT_B      = get_header("total_live_time", tgtB.c_str(),  kinB.c_str());

  // transparencies
  transparency_A  = get_param("transparency", tgtA.c_str(),  kinA.c_str());
  transparency_B  = get_param("transparency", tgtB.c_str(),  kinB.c_str());

  A_tgtA  = get_param("A", tgtA.c_str(),  kinA.c_str());
  A_tgtB  = get_param("A", tgtB.c_str(),  kinB.c_str());

  Z_tgtA  = get_param("Z", tgtA.c_str(),  kinA.c_str());
  Z_tgtB  = get_param("Z", tgtB.c_str(),  kinB.c_str());

  
  // target areal density [g/cm^2]
  tgt_area_density_A  = get_param("tgt_area_density", tgtA.c_str(),  kinA.c_str());
  tgt_area_density_B  = get_param("tgt_area_density", tgtB.c_str(),  kinB.c_str());

  // putting everyting together . . .  
  scale_factor_A   = 1. / ( Q_A * hms_trk_eff_A * shms_trk_eff_A * shms_mult_trk_eff_A * total_LT_A * transparency_A * tgt_area_density_A * Z_tgtA/A_tgtA) ;
  scale_factor_B   = 1. / ( Q_B * hms_trk_eff_B * shms_trk_eff_B * shms_mult_trk_eff_B * total_LT_B * transparency_B * tgt_area_density_B * Z_tgtB/A_tgtB) ;

  // PRINT OUT scale factor and its components for sanity checking
  cout << "" << endl;
  cout << "#---------------------------" << endl;
  cout << Form(" %s %s Scaler Factors: ", tgtA.c_str(), kinA.c_str() ) << endl;
  cout << "#---------------------------" << endl;
  cout << Form("charge [mC]                 : %.3f", Q_A ) << endl;
  cout << Form("avg. hms  track eff         : %.3f", hms_trk_eff_A ) << endl;
  cout << Form("avg. shms track eff         : %.3f", shms_trk_eff_A ) << endl;
  cout << Form("avg. shms mult. track eff   : %.3f", shms_mult_trk_eff_A ) << endl;
  cout << Form("avg. total live time        : %.3f", total_LT_A  ) << endl;
  cout << Form("(Z, A, T)                   : %.0f, %.0f, %.3f", Z_tgtA, A_tgtA, transparency_A  ) << endl;
  cout << Form("tgt. areal density [g/cm^2] : %.4f", tgt_area_density_A   ) << endl;
  cout << Form("scale factor                : %.5f", scale_factor_A ) << endl;
  cout << "" << endl;
  cout << "" << endl;
  cout << "#---------------------------" << endl;
  cout << Form(" %s %s Scaler Factors: ", tgtB.c_str(), kinB.c_str() ) << endl;
  cout << "#---------------------------" << endl;
  cout << Form("charge [mC]                 : %.3f", Q_B ) << endl;
  cout << Form("avg. hms  track eff         : %.3f", hms_trk_eff_B ) << endl;
  cout << Form("avg. shms track eff         : %.3f", shms_trk_eff_B ) << endl;
  cout << Form("avg. shms mult. track eff   : %.3f", shms_mult_trk_eff_B ) << endl;
  cout << Form("avg. total live time        : %.3f", total_LT_B  ) << endl;
  cout << Form("(Z, A, T)                   : %.0f, %.0f, %.3f", Z_tgtB, A_tgtB, transparency_A  ) << endl;
  cout << Form("tgt. areal density [g/cm^2] : %.4f", tgt_area_density_B   ) << endl;
  cout << Form("scale factor                : %.5f", scale_factor_B ) << endl;
  cout << "" << endl;
  
  // set .root file names 
  string fname_A = Form(ANALYZED_COMBINED"cafe_prod_%s_%s_combined.root", tgtA.c_str(), kinA.c_str());
  string fname_B = Form(ANALYZED_COMBINED"cafe_prod_%s_%s_combined.root", tgtB.c_str(), kinB.c_str());

  cout << Form("FILES TO OPEN: \n%s\n%s", fname_A.c_str(), fname_B.c_str() ) << endl;

  // define TFile
  TFile *file_A  = NULL;
  TFile *file_B = NULL;
    
  
  TH1F *H_hist_A  = 0;  
  TH1F *H_hist_B = 0;
  //TH1F *H_hist_R = 0;
    
  // read TFile
  file_A = new TFile(fname_A.c_str());
  file_B = new TFile(fname_B.c_str());

   
  // get histogram objects
  file_A->cd(); 
  file_A->GetObject(hist_name.c_str(), H_hist_A);
  extract_1d_hist(H_hist_A, "Missing Momentum Pm [GeV/c]", "Raw Counts", Form("raw_histo1D_%s_%s_Pm_bins.csv", tgtA.c_str(), kinA.c_str()));

  // scale histogram appropiately
  H_hist_A->Scale(scale_factor_A);
  
    
  file_B->cd();
  file_B->GetObject(hist_name.c_str(), H_hist_B);
  extract_1d_hist(H_hist_B, "Missing Momentum Pm [GeV/c]", "Raw Counts", Form("raw_histo1D_%s_%s_Pm_bins.csv", tgtB.c_str(), kinB.c_str()));

  // scale histogram appropiately
  H_hist_B->Scale(scale_factor_B);
  

  // calculate the ratio (A * scale_factor / (B * scale_factor) )
  TH1F *H_hist_R = (TH1F*)H_hist_A->Clone("H_hist_R");
  H_hist_R->Divide(H_hist_A, H_hist_B);

  if(show_histos) {

    int font_type = 132;
    gStyle->SetTitleFontSize(0.07);
    gStyle->SetTitleFont(font_type, "");
    gStyle->SetLegendBorderSize(0);
    gStyle->SetLegendFont(font_type);
    gStyle->SetLegendTextSize(0.05);
  
    // set histos aethetics
  H_hist_A->SetLineColor(kRed);
  H_hist_A->SetLineWidth(2);
  //H_hist_A->SetFillColorAlpha(kRed, 0.40);
  //H_hist_A->SetFillStyle(3004);

  H_hist_B->SetLineColor(kBlue);
  H_hist_B->SetLineWidth(2);
  //H_hist_B->SetFillColorAlpha(kBlue, 0.40);
  //H_hist_B->SetFillStyle(3005);

  H_hist_R->SetLineColor(kBlack);
  //H_hist_R->SetFillColorAlpha(kBlack, 0.40);
  //H_hist_R->SetFillStyle(3005);
  
  // set histogram titles/labels/font
  H_hist_A->SetTitle(H_hist_A->GetTitle());
  
  H_hist_A->GetXaxis()->SetLabelSize(0.04);
  H_hist_A->GetYaxis()->SetLabelSize(0.04);

  H_hist_A->SetLabelFont(font_type, "XY");
  
  H_hist_R->SetLabelFont(font_type, "XY");
  H_hist_R->GetXaxis()->SetLabelSize(0.04);
  H_hist_R->GetYaxis()->SetLabelSize(0.04);
  H_hist_R->SetMarkerStyle(8);
  H_hist_R->SetMarkerSize(0.8);
  H_hist_R->SetMarkerColor(kBlack);

  // set histos proper names
  H_hist_A->SetName(Form("%s_%s", tgtA.c_str(), kinA.c_str()));
  H_hist_B->SetName(Form("%s_%s", tgtB.c_str(), kinB.c_str()));
  H_hist_R->SetName(Form("Ratio %s%s/%s%s", tgtA.c_str(), kinA.c_str(), tgtB.c_str(), kinB.c_str()));
  H_hist_R->SetTitle("Single SRC Ratio Ca-48/40");
     
    TCanvas *c = new TCanvas("c", "", 800,1200);
    c->Divide(1,2);

    c->cd(1);
    H_hist_A->SetStats(0);
    H_hist_B->SetStats(0);
    H_hist_A->Draw("histE0");
    H_hist_B->Draw("sameshistE0");
  
    // create legend ( displays hist legend label and integral counts)
    TLegend *leg1 = new TLegend(0.14,0.89,0.25,0.65);
    double h1_I, h2_I;
    double h1_Ierr, h2_Ierr;
    double nbins = H_hist_A->GetNbinsX();  //Get total number of bins (excluding overflow)
    h1_I = H_hist_A->IntegralAndError(1, nbins, h1_Ierr);
    h2_I = H_hist_B->IntegralAndError(1, nbins, h2_Ierr);
    
    leg1->AddEntry(H_hist_A,Form("#splitline{%s %s}{Integral: %.3f #pm %.2f}", tgtA.c_str(), kinA.c_str(), h1_I, h1_Ierr), "f");
    leg1->AddEntry(H_hist_B,Form("#splitline{%s %s}{Integral: %.3f #pm %.2f}", tgtB.c_str(), kinB.c_str(), h2_I, h2_Ierr), "f");
    // draw legend
    leg1->Draw();

    c->cd(2);


    H_hist_R->SetStats("n");
    gStyle->SetErrorX(0);
    H_hist_R->Draw();


  }

  // Write Numerical information from histogram to external .csv file (method in hist_utils.h)
  extract_1d_hist(H_hist_A, "Missing Momentum Pm [GeV/c]", "Charge-Norm Yield", Form("histo1D_%s_%s_Pm_bins.csv", tgtA.c_str(), kinA.c_str()));
  extract_1d_hist(H_hist_B, "Missing Momentum Pm [GeV/c]", "Charge-Norm Yield", Form("histo1D_%s_%s_Pm_bins.csv", tgtB.c_str(), kinB.c_str()));
  extract_1d_hist(H_hist_R, "Missing Momentum Pm [GeV/c]", "%s/%s SRC Ratio", Form("histo1D_%s%sto%s%s_Pm_bins.csv", tgtA.c_str(),kinA.c_str(),tgtB.c_str(),kinB.c_str()));
  
  // save histograms to a vector to be returned to the user
 
  vector<TH1F*> hvec;
  

  hvec.push_back(H_hist_A);
  hvec.push_back(H_hist_B);
  hvec.push_back(H_hist_R);

  
  return hvec;

}



void yield_comparison(TString target="", TString kin="", Int_t run=-1, Int_t hist_id=-1) {
  
  // ---------- compare DATA /  SIMC  H(e,e'p) --------------------
  
  // If dealing with multiole runs, or multiple histograms, one can always put this in a loop
   
  double Q          = get_header("total_charge", target.Data(), kin.Data(), run);
  double htrk_eff   = get_header("hms_trk_eff",  target.Data(), kin.Data(), run );
  double etrk_eff   = get_header("shms_trk_eff", target.Data(), kin.Data(), run );
  double e_mtrk_eff = get_header("shms_mult_trk_eff", target.Data(), kin.Data(), run );
  double tLT        = get_header("total_live_time", target.Data(),  kin.Data(), run);
  double tgt_thick = get_param("tgt_area_density",target.Data(), kin.Data() );
  double A          = get_param("A",target.Data(), kin.Data() );
  double Z          = get_param("Z",target.Data(), kin.Data() );

  double T         = 1;  

  double scale1 = 1. / (Q *  htrk_eff * etrk_eff * e_mtrk_eff * tLT  * tgt_thick * Z/A);
  double scale2 = 1. / (tgt_thick * Z/A);  // simulation scale factor (SIMC is already 1 mC, and efficiencies are 100% )

  // LH2
  TString file1_path;
  TString file2_path;

  
  TString hist1="randSub_plots/H_Pm_rand_sub";
  TString hist2="kin_plots/H_Pm";
  TString xlabel="Missing Momentum, Pm [GeV/c]";
  TString ylabel="Charge-Normalized Yield ";
  TString title = "CaFe H(e,e'p): Missing Momentum";
  TString hist1_leg="DATA";
  TString hist2_leg="SIMC";


  // ---------- compare DATA /  SIMC for  MF, SRC for other targets--------------------

  // User Input
  //cout << "Enter (target, kin, run, hist_id): \n example: C12 MF 17098 0 \n example2: LH2 heep_coin 16962 1 \n";
  cout <<  "hist_id: \n 0: Pm, 1: W, 2: Q2, 3: xbj, 4: nu, 5: Em, 6: th_rq, 7: th_pq \n 8: th_e, 9: kf, 10: th_p, 11: Pf, 12: |q|, 13: th_q, 14: Pmx_lab, \n 15: Pmy_lab, 16: Pmz_lab " << endl;
  //cin >> target >> kin >> run >> hist_id;
  cout << "--------------" << endl;
  cout << "target: " << target.Data() << endl;
  cout << "kin   : " << kin.Data() << endl;
  cout << "run   : " << run << endl;
  cout << "hist_id   : " << hist_id << endl;
  cout << "--------------" << endl;
  cout << "" << endl;
  
  Q          = get_header("total_charge", target.Data(), kin.Data(), run);
  htrk_eff   = get_header("hms_trk_eff",  target.Data(), kin.Data(), run );
  etrk_eff   = get_header("shms_trk_eff", target.Data(), kin.Data(), run );
  e_mtrk_eff = get_header("shms_mult_trk_eff", target.Data(), kin.Data(), run );
  tLT        = get_header("total_live_time", target.Data(),  kin.Data(), run);

  tgt_thick = get_param("tgt_area_density",target.Data(), kin.Data() );
  A          = get_param("A",target.Data(), kin.Data() );
  Z          = get_param("Z",target.Data(), kin.Data() );

  double alpha=0.24;
  T = pow(A, -alpha); // TRASNPARENCY BASED ON previous fits
    
  scale1 = 1. / (Q *  htrk_eff * etrk_eff * e_mtrk_eff * tLT  * tgt_thick * Z/A);
  scale2 = 1. / (tgt_thick * Z/A);  // simulation scale factor (SIMC is already 1 mC, and efficiencies are 100% )
  
  file1_path = Form("~/ROOTfiles/pass3_files/data/cafe_prod_%s_%s_%i_-1_histos.root", target.Data(), kin.Data(), run);
  
  file2_path = Form("~/ROOTfiles/pass3_files/simc/cafe_%s_%s_rad_analyzed.root", target.Data(), kin.Data());

  if(target=="LH2")   file2_path = Form("~/ROOTfiles/pass3_files/simc/cafe_%s_kin0_rad_analyzed.root", kin.Data());

  
  cout << Form("reading data file1: %s", file1_path.Data()) << endl;
  cout << Form("reading simc file2: %s", file2_path.Data()) << endl;

  cout << "" << endl;
  cout << "----------------------------" << endl;
  cout << Form("%s %s %i Scale Factors", target.Data(), kin.Data(), run) << endl;
  cout << "----------------------------" << endl;
  cout << " " << endl;
  cout << "data scale_factor =  1 / (Q * hms_trk_eff * \n  \t shms_trk_eff * shms_multi_trk_eff * \n \t total_live_time * tgt_thick * Z / A) " << endl;
  cout << Form("data scale_factor -->  %.4f", scale1) << endl;
  cout << "" << endl;
  cout << "simc scale_factor =  1 / (tgt_thick * Z / A) " << endl;
  cout << Form("simc scale_factor -->  %.4f", scale2) << endl;
  cout << "" << endl;
  cout << Form("(A, Z, T) : %.1f, %.1f, %.3f ", A, Z, T) << endl;  
  cout << Form("Charge Q [mC]      : %.3f ", Q) << endl;
  cout << Form("HMS Trk Eff        : %.3f", htrk_eff) << endl;
  cout << Form("SHMS Trk Eff       : %.3f", etrk_eff) << endl;
  cout << Form("SHMS Mult. Trk Eff : %.3f", e_mtrk_eff) << endl;
  cout << Form("Total Live Time    : %.3f", tLT) << endl;
  cout << Form("Target Thick [g/cm2] : %.4f", tgt_thick) << endl;
  cout << "-----------------------------" << endl;
  cout << "" << endl;



  
  // Create arrays of histogram object names

  TString hist1_randSub_dir = "randSub_plots/";
  TString hist1_kin_dir = "kin_plots/";
    
  TString hist2_kin_dir = "kin_plots/";

  TString title_prefix      = Form("%s %s (run %i) ", target.Data(), kin.Data(), run);
  TString title_arr[18]      = {"Missing Momentum, P_{m}",  "Invariant Mass, W", "4-Momentum Transfer", "x-Bjorken", "Energy Transfer, #nu", "Missing Energy, E_{m}", "Recoil Angle, #theta_{rq}", "In-Plane Angle, #theta_{pq}",
			       "Electron (SHMS) Angle, #theta_{e}",  "Electron (SHMS) Momentum, k_{f} [GeV/c]", "Proton Angle, #theta_{p}", "Proton Momentum, p_{f} [GeV/c]",
			       "3-Momentum, |#vec{q}|",  "In-Plane Angle, #theta_{q}", "Missing Momentum X, P_{mx}", "Missing Momentum Y, P_{my}",
			       "Missing Momentum Z, P_{mz}"};

  TString hist1_name[18] = {"H_Pm_rand_sub", "H_W_rand_sub", "H_Q2_rand_sub", "H_xbj_rand_sub", "H_nu_rand_sub", "H_Em_nuc_rand_sub",  "H_thrq_rand_sub",  "H_thxq_rand_sub",
			    "H_the",         "H_kf",          "H_thx",          "H_Pf",          "H_q",                "H_thq",  
			    "H_Pmx_Lab",          "H_Pmy_Lab",      "H_Pmz_Lab"};
  if(target=="LH2"){
    hist1_name[5] = "H_Em_rand_sub";
  }

  TString hist2_name[18] = {"H_Pm",          "H_W", "H_Q2",          "H_xbj",          "H_nu",          "H_Em",               "H_thrq",   "H_thxq",
			    "H_the",         "H_kf",          "H_thx",          "H_Pf",           "H_q",               "H_thq", 
			    "H_Pmx_Lab",          "H_Pmy_Lab",      "H_Pmz_Lab"};

  TString xlabel_arr[18]     = {"Pm [GeV/c]",  "W [GeV]", "Q^{2} [GeV^{2}]", "x_{Bj}",      "#nu [GeV]",     "E_{m} [GeV]",        "#theta_{rq} [deg]",     "#theta_{pq} [deg]",
				"#theta_{e} [deg]", "k_{f} [GeV/c]",  "#theta_{p} [deg]",  "P_{f} [GeV/c]",  "|#vec{q}| [GeV/c]", " #theta_{q} [deg]", 
				"P_{mx,lab} [GeV]", "P_{my,lab} [GeV]", "P_{mz,lab} [GeV]"  };
  


  cout << "title: " << title_arr[hist_id].Data() << endl;
  // plot randoms-subtracted histos from data (compared to simc)
  if(hist_id<8) {
    hist1 = hist1_randSub_dir + hist1_name[hist_id];
    hist2 = hist2_kin_dir + hist2_name[hist_id];
  }

  // plot histograms under kin_plots/ dir for both data/simc (all cuts, but not random-subtracted)
  else if(hist_id>=8){
    hist1 = hist1_kin_dir + hist1_name[hist_id];
    hist2 = hist2_kin_dir + hist2_name[hist_id];
  }

  // plot histograms under accp_plots


  
  title = title_prefix + title_arr[hist_id];
  ylabel="Charge-Normalized Yield ";
  hist1_leg="DATA";
  hist2_leg="SIMC";
  
  
  // loop over kinematic histograms
  // draw normalized to area of 1
  /*
   compare_histos( file1_path, hist1,        scale1,
		  file2_path, hist2,        scale2,
		  xlabel_arr[hist_id],      ylabel,     title,
		  hist1_leg,  hist2_leg,    true);
  */
  
  // draw with proper data yield scales
  compare_histos( file1_path, hist1,        scale1,
		  file2_path, hist2,        scale2,
		  xlabel_arr[hist_id],      ylabel,     title,
		  hist1_leg,  hist2_leg,    false);
  
}

